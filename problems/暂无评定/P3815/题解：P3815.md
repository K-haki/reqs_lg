这题目前没发现什么满分做法，不过有一种复杂度不满的算法可以得90分。
记 f(l1,r1,l2,r2)f(l_1,r_1,l_2,r_2)f(l1​,r1​,l2​,r2​) 为 X[l1,r1]X[l_1,r_1]X[l1​,r1​] 和 Y[l2,r2]Y[l_2,r_2]Y[l2​,r2​] 的最长公共回文子序列长度。
不难想到转移：当 X[l1]=X[r1]=Y[l2]=Y[r2]X[l_1]=X[r_1]=Y[l_2]=Y[r_2]X[l1​]=X[r1​]=Y[l2​]=Y[r2​] 时，每个序列的两端显然应属于最长回文子序列，f(l1,r1,l2,r2)=f(l1+1,r1−1,l2+1,r2−1)+1f(l_1,r_1,l_2,r_2)=f(l_1+1,r_1-1,l_2+1,r_2-1)+1f(l1​,r1​,l2​,r2​)=f(l1​+1,r1​−1,l2​+1,r2​−1)+1，否则 f(l1,r1,l2,r2)=max⁡{f(l1+1,r1,l2,r2),f(l1,r1+1,l2,r2),f(l1,r1,l2+1,r2),f(l1,r1,l2,r2+1)}f(l_1,r_1,l_2,r_2)=\max\{f(l_1+1,r_1,l_2,r_2),f(l_1,r_1+1,l_2,r_2),f(l_1,r_1,l_2+1,r_2),f(l_1,r_1,l_2,r_2+1)\}f(l1​,r1​,l2​,r2​)=max{f(l1​+1,r1​,l2​,r2​),f(l1​,r1​+1,l2​,r2​),f(l1​,r1​,l2​+1,r2​),f(l1​,r1​,l2​,r2​+1)}（l1&lt;r1,l2&lt;r2l_1 &lt; r_1,l_2 &lt; r_2l1​&lt;r1​,l2​&lt;r2​）。边界是 l1≥r1l_1\ge r_1l1​≥r1​ 或 l2≥r2l_2\ge r_2l2​≥r2​ 的情况。
然而这样做的复杂度是满的，得分反而不高。
考虑换一种转移方式：枚举子序列中下一个出现的元素 ccc，用 lastX(i,c)\mathrm{last}_X(i,c)lastX​(i,c)、next(i,c)\mathrm{next}(i,c)next(i,c) 表示 XXX 从 iii 位置往左、右第一个 ccc 的出现位置，则 f(l1,r1,l2,r2)=max⁡c{f(nextX(l1,c)+1,lastX(r1,c)−1,nextY(l2,c)+1,lastY(r2,c)−1)}+1f(l_1,r_1,l_2,r_2)=\max_c\{f(\mathrm{next}_X(l_1,c)+1,\mathrm{last}_X(r_1,c)-1,\mathrm{next}_Y(l_2,c)+1,\mathrm{last}_Y(r_2,c)-1)\}+1f(l1​,r1​,l2​,r2​)=maxc​{f(nextX​(l1​,c)+1,lastX​(r1​,c)−1,nextY​(l2​,c)+1,lastY​(r2​,c)−1)}+1，当不存在转移时为 000。
注意 ccc 只要枚举同时出现在两个序列中的即可，所以最多 nnn 种。
这样做的复杂度看起来是 O(n5)O(n^5)O(n5) 的，但大多数据都达不到。为什么呢？因为 fff 状态的四个端点的元素是相同的，这样的状态并不满，可以用Hash表存储状态，就能以 O(n5log⁡n)O(n^5\log n)O(n5logn) 或 O(n5)O(n^5)O(n5) 的复杂度得到90分。
